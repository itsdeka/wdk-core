{"version":3,"sources":["../src/SolanaWallet.ts","../src/TestWalletAdapter.ts"],"names":["WalletReadyState","transaction"],"mappings":"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","sourcesContent":["import {\n  type ChainKey,\n  ChainType,\n  tryGetNetworkByNativeChainId,\n  waitFor,\n  assert,\n} from '@layerzerolabs/ui-core';\nimport type {SolanaSigner as ISolanaSigner, SolanaTransaction} from '@layerzerolabs/ui-solana';\nimport {AbstractWallet} from '@layerzerolabs/ui-wallet';\nimport {type SignerWalletAdapter, WalletReadyState} from '@solana/wallet-adapter-base';\nimport {action, computed, flow, makeObservable, transaction} from 'mobx';\n\nenum NativeChainId {\n  MAINNET = 1,\n  TESTNET = 2,\n}\n\nclass SolanaSigner implements ISolanaSigner {\n  constructor(public readonly adapter: SignerWalletAdapter) {}\n  sendTransaction: ISolanaSigner['sendTransaction'] = async (\n    payload: SolanaTransaction,\n    {connection, ...options},\n  ) => {\n    this.adapter.sendTransaction(payload, connection, options);\n    const hash = await this.adapter.sendTransaction(payload, connection);\n    return {hash};\n  };\n\n  signTransaction<Transaction extends SolanaTransaction>(\n    payload: Transaction,\n  ): Promise<Transaction> {\n    return this.adapter.signTransaction(payload);\n  }\n}\n\nexport class SolanaWallet extends AbstractWallet<SolanaSigner> {\n  public signer?: SolanaSigner | undefined = undefined;\n  async getAddress(): Promise<string> {\n    const address = this.signer?.adapter.publicKey?.toString();\n    if (address) return address;\n    throw new Error('Could not get address');\n  }\n\n  async getNativeChainId(): Promise<number> {\n    return networkToNativeChainId(this.network);\n  }\n\n  get icon() {\n    return this.adapter.icon;\n  }\n\n  get type(): string {\n    return this.adapter.name;\n  }\n\n  public readonly chainType = ChainType.SOLANA;\n\n  constructor(\n    public readonly adapter: SignerWalletAdapter,\n    public network: 'mainnet' | 'testnet' | 'sandbox',\n  ) {\n    super();\n\n    makeObservable(this, {\n      isAvailable: true,\n      chainKey: computed,\n      isConnected: true,\n      isConnecting: true,\n      isSwitchingChain: true,\n      publicKey: true,\n      nativeChainId: true,\n      address: true,\n      signer: true,\n    });\n\n    this.signer = new SolanaSigner(adapter);\n    this.subscribe();\n    // in case wallet already updated it will not emit readyStateChange\n    this.update();\n  }\n\n  private subscribe() {\n    this.adapter.addListener('connect', this.update);\n    this.adapter.addListener('disconnect', this.update);\n    this.adapter.addListener('readyStateChange', this.update);\n  }\n\n  public autoConnect: () => Promise<void> = async () => {\n    if (!this.isAutoConnectEnabled) return Promise.reject();\n    try {\n      await waitFor(() => this.adapter.readyState === WalletReadyState.Installed, {timeout: 3000});\n      await this.connect();\n    } catch (e) {\n      this.isAutoConnectEnabled = false;\n      throw e;\n    }\n  };\n\n  // must be public because of makeObservable\n  protected update = action(() => {\n    this.publicKey = this.adapter.publicKey?.toString();\n    this.address = this.publicKey;\n    this.isConnected = this.adapter.connected;\n    this.isConnecting = this.adapter.connected ? false : this.adapter.connecting;\n    this.isAvailable = this.adapter.readyState === WalletReadyState.Installed;\n    // todo: detect native chain id\n    this.nativeChainId = networkToNativeChainId(this.network);\n    this.isAutoConnectEnabled = this.isAutoConnectEnabled || this.isConnected;\n  });\n\n  connect: () => Promise<void> = flow(\n    function* (this: SolanaWallet) {\n      assert(this.isConnected === false);\n      assert(this.isConnecting === false);\n      this.isConnecting = true;\n      try {\n        yield this.adapter.connect();\n        if (!this.isConnected) {\n          // in case the wallet didn't sync\n          this.update();\n        }\n      } finally {\n        this.isConnecting = false;\n      }\n    }.bind(this),\n  );\n\n  disconnect: () => Promise<void> = flow(\n    function* (this: SolanaWallet) {\n      this.isAutoConnectEnabled = false;\n      yield this.adapter.disconnect();\n    }.bind(this),\n  );\n\n  switchChain = async (chainKey: ChainKey): Promise<void> => {\n    this.network = chainKeyToNetwork(chainKey);\n  };\n\n  public get chainKey(): ChainKey | undefined {\n    return tryGetNetworkByNativeChainId(this.chainType, this.nativeChainId)?.chainKey;\n  }\n}\n\nfunction chainKeyToNetwork(chainKey: string): 'mainnet' | 'testnet' {\n  switch (chainKey) {\n    case 'solana':\n      return 'mainnet';\n    case 'solana-testnet':\n      return 'testnet';\n    default:\n      throw new Error(`Unsupported network ${chainKey}`);\n  }\n}\n\nfunction networkToNativeChainId(network: string) {\n  switch (network) {\n    case 'mainnet':\n      return NativeChainId.MAINNET;\n    case 'testnet':\n      return NativeChainId.TESTNET;\n    default:\n      throw new Error('Unsupported network');\n  }\n}\n","import {\n  BaseWalletAdapter,\n  type SendTransactionOptions,\n  type SignerWalletAdapter,\n  type SupportedTransactionVersions,\n  type TransactionOrVersionedTransaction,\n  WalletReadyState,\n  type WalletName,\n} from '@solana/wallet-adapter-base';\nimport {type Connection, type Keypair, type PublicKey, VersionedTransaction} from '@solana/web3.js';\n\nexport class TestWalletAdapter extends BaseWalletAdapter implements SignerWalletAdapter {\n  name = 'Test Wallet' as WalletName<'Test Wallet'>;\n  url: string = '';\n  icon: string = 'https://icons-ckg.pages.dev/stargate-light/wallets/test.svg';\n  readyState = WalletReadyState.Installed;\n  supportedTransactionVersions?: SupportedTransactionVersions;\n\n  protected _state: 'connected' | 'disconnected' | 'connecting' = 'disconnected';\n  protected _keypair: Keypair;\n\n  get publicKey(): PublicKey | null {\n    if (this._state === 'connected') {\n      return this._keypair.publicKey;\n    }\n    return null;\n  }\n\n  get connecting() {\n    return this._state === 'connecting';\n  }\n\n  async connect(): Promise<void> {\n    this._state = 'connected';\n    this.emit('connect', this._keypair.publicKey);\n  }\n\n  async disconnect(): Promise<void> {\n    this._state = 'disconnected';\n    this.emit('disconnect');\n  }\n  async sendTransaction(\n    transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n    connection: Connection,\n    options?: SendTransactionOptions | undefined,\n  ): Promise<string> {\n    const singedTransaction = await this.signTransaction(transaction);\n    const isVersionedTransaction = singedTransaction instanceof VersionedTransaction;\n    if (!isVersionedTransaction) throw new Error('Only VersionedTransaction is supported.');\n    const hash = await connection.sendTransaction(singedTransaction);\n    return hash;\n  }\n\n  constructor(config: {keypair: Keypair}) {\n    super();\n    this._keypair = config.keypair;\n  }\n  async signTransaction<\n    T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n  >(transaction: T): Promise<T> {\n    const isVersionedTransaction = transaction instanceof VersionedTransaction;\n    if (!isVersionedTransaction) throw new Error('Only VersionedTransaction is supported.');\n    await transaction.sign([this._keypair]);\n    return transaction;\n  }\n\n  signAllTransactions<\n    T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n  >(transactions: T[]): Promise<T[]> {\n    throw new Error('Method not implemented.');\n  }\n}\n"]}
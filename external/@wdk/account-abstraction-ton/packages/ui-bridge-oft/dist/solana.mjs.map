{"version":3,"sources":["../src/solana/OftBridgeV3__solana.ts"],"names":[],"mappings":"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","sourcesContent":["import {hexlify} from '@ethersproject/bytes';\nimport {OftPDADeriver, OftProgram, OftTools, SendHelper} from '@layerzerolabs/lz-solana-sdk-v2';\nimport {\n  type GetMessageFeeInput,\n  type GetOutputInput,\n  type BridgeOutput,\n  type GetDurationInput,\n  type GetLimitInput,\n  type GetExtraGasInput,\n  type GetAllowanceInput,\n  type GetOptionsInput,\n  type BridgeOptions,\n  type GetUnclaimedInput,\n  type IsRegisteredInput,\n  type TransferInput,\n  type ClaimInput,\n  type RegisterInput,\n  type ApproveInput,\n  type BridgeOption,\n  validateInput,\n} from '@layerzerolabs/ui-bridge-sdk/v1';\nimport {\n  type Currency,\n  type FeeQuote,\n  CurrencyAmount,\n  type Transaction,\n  type ChainKey,\n  isToken,\n  assert,\n  isSolanaChainKey,\n  MaxUint256,\n  MessageFee,\n  castCurrencyAmountUnsafe,\n  AdapterParams,\n  hasAddress,\n} from '@layerzerolabs/ui-core';\nimport {addressToBytes32} from '@layerzerolabs/ui-evm';\nimport {\n  type SolanaSigner,\n  createTransaction,\n  getSimulationComputeUnits,\n} from '@layerzerolabs/ui-solana';\nimport {getAssociatedTokenAddress, TOKEN_PROGRAM_ID} from '@solana/spl-token';\nimport type {AccountMeta} from '@solana/web3.js';\nimport {\n  type AddressLookupTableAccount,\n  type Commitment,\n  ComputeBudgetProgram,\n  type Connection,\n  type GetAccountInfoConfig,\n  type MessageV0,\n  PublicKey,\n  type TransactionInstruction,\n  TransactionMessage,\n  VersionedTransaction,\n} from '@solana/web3.js';\nimport moize from 'moize';\n\nimport type {OftBridgeApi, OftBridgeConfig, OftBridgeFee} from '../types';\nimport {createOptions} from '../utils';\n\nexport class OftBridgeV3__solana implements OftBridgeApi<SolanaSigner> {\n  protected sendHelper = new SendHelper();\n  protected derivers: Record<ChainKey, OftPDADeriver> = {};\n  protected logger: typeof console | undefined = undefined;\n\n  constructor(\n    protected readonly connection: Connection,\n    public readonly config: OftBridgeConfig,\n    {\n      cacheTime = 0,\n      verbose = false,\n    }: {\n      verbose?: boolean;\n      // in ms\n      cacheTime?: number;\n    } = {},\n  ) {\n    this.validateConfig(config);\n\n    if (verbose) {\n      this.logger = console;\n    }\n\n    if (cacheTime > 0) {\n      const options = {\n        isDeepEqual: true,\n        isPromise: true,\n        maxSize: 1_000,\n        maxAge: cacheTime,\n      };\n\n      this.quoteOft = moize(this.quoteOft.bind(this), options);\n      this.getMessageFee = moize(this.getMessageFee.bind(this), options);\n      this.getPeerInfo = moize(this.getPeerInfo.bind(this), options);\n      this.getQuoteAccounts = moize(this.getQuoteAccounts.bind(this), options);\n      this.getSendAccounts = moize(this.getSendAccounts.bind(this), options);\n    }\n  }\n\n  protected getConnection(chainKey: ChainKey) {\n    // todo: support multiple connections if OFT deployed on multiple solana networks\n    return this.connection;\n  }\n\n  protected getTokenProgramId(chainKey: ChainKey) {\n    return TOKEN_PROGRAM_ID;\n  }\n\n  protected getOftProgramId(chainKey: ChainKey) {\n    const deployment = this.getDeployment(chainKey);\n    assert(deployment.oft?.programId, 'programId is required');\n    return new PublicKey(deployment.oft.programId);\n  }\n\n  protected getDeriver(chainKey: ChainKey) {\n    if (!this.derivers[chainKey]) {\n      const oftProgramId = this.getOftProgramId(chainKey);\n      const deriver = new OftPDADeriver(oftProgramId);\n      this.derivers[chainKey] = deriver;\n    }\n    return this.derivers[chainKey];\n  }\n\n  protected getOftInstance(chainKey: ChainKey): PublicKey {\n    const deriver = this.getDeriver(chainKey);\n    const deployment = this.getDeployment(chainKey);\n    assert(hasAddress(deployment.token), 'Token address is required');\n    const tokenMint = new PublicKey(deployment.token.address);\n    const tokenEscrow = deployment.tokenEscrow\n      ? new PublicKey(deployment.tokenEscrow.address)\n      : undefined;\n    return deriver.oftConfig(tokenEscrow ?? tokenMint)[0];\n  }\n\n  protected validateConfig(config: OftBridgeConfig) {\n    // todo: validate that solana has programId\n    assert(config.version === 3, 'OftBridgeConfig version 3 is required');\n  }\n\n  supportsClaim(token: Currency): boolean {\n    return this.supportsRegister(token);\n  }\n\n  supportsRegister(token: Currency): boolean {\n    const {chainKey} = token;\n    if (!isSolanaChainKey(chainKey)) return false;\n    return Boolean(this.tryGetDeployment(token.chainKey)?.token.equals(token));\n  }\n\n  supportsTransfer(srcToken: Currency, dstToken: Currency): boolean {\n    return Boolean(\n      isSolanaChainKey(srcToken.chainKey) &&\n        this.tryGetDeployment(srcToken.chainKey)?.token.equals(srcToken) &&\n        this.tryGetDeployment(dstToken.chainKey)?.token.equals(dstToken),\n    );\n  }\n\n  protected async getQuoteAccounts(\n    srcChainKey: ChainKey,\n    srcAddress: string,\n    dstEid: number,\n  ): Promise<AccountMeta[]> {\n    const connection = this.getConnection(srcChainKey);\n    const oftInstance = this.getOftInstance(srcChainKey);\n    const peer = this.getPeer(srcChainKey, dstEid);\n    const payer = new PublicKey(srcAddress);\n    const peerInfo = await this.getPeerInfo(connection, peer);\n    const remainingAccounts = await this.sendHelper.getQuoteAccounts(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      connection as any,\n      payer,\n      oftInstance,\n      dstEid,\n      hexlify(peerInfo.address),\n    );\n    return remainingAccounts;\n  }\n\n  protected async getSendAccounts(\n    srcChainKey: ChainKey,\n    srcAddress: string,\n    dstEid: number,\n  ): Promise<AccountMeta[]> {\n    const connection = this.getConnection(srcChainKey);\n    const payer = new PublicKey(srcAddress);\n    const oftInstance = this.getOftInstance(srcChainKey);\n    const peer = this.getPeer(srcChainKey, dstEid);\n    const peerInfo = await this.getPeerInfo(connection, peer);\n    const remainingAccounts = await this.sendHelper.getSendAccounts(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      connection as any,\n      payer,\n      oftInstance,\n      dstEid,\n      hexlify(peerInfo.address),\n    );\n    return remainingAccounts;\n  }\n\n  async getMessageFee(input: GetMessageFeeInput): Promise<FeeQuote> {\n    this.logger?.log('getMessageFee', input);\n    if (!input.srcAddress) throw new Error('srcAddress is required');\n    if (!isToken(input.srcToken)) throw new Error('srcToken is required');\n    if (!input.srcAmount) throw new Error('srcAmount is required');\n    if (!input.dstAmountMin) throw new Error('dstAmountMin is required');\n    if (!input.dstAddress) throw new Error('dstAddress is required');\n    const srcChainKey = input.srcToken.chainKey;\n    const dstChainKey = input.dstToken.chainKey;\n    const deployment = this.getDeployment(srcChainKey);\n    const dstEid = this.chainKeyToEndpointId(dstChainKey);\n    const payer = new PublicKey(input.srcAddress);\n    const tokenMint = new PublicKey(input.srcToken.address);\n    const amountLd = input.srcAmount.toBigInt();\n    const minAmountLd = castCurrencyAmountUnsafe(input.dstAmountMin, input.srcToken).toBigInt();\n    const to = addressToBytes32(input.dstAddress);\n    const tokenEscrow = deployment.tokenEscrow\n      ? new PublicKey(deployment.tokenEscrow.address)\n      : undefined;\n    const composeMsg = undefined;\n    const {adapterParams} = input;\n    const payInLzToken = false;\n    const peer = this.getPeer(srcChainKey, dstEid);\n    const connection = this.getConnection(srcChainKey);\n    const tokenProgramId = this.getTokenProgramId(srcChainKey);\n    const oftProgramId = this.getOftProgramId(srcChainKey);\n\n    // don't waterfall\n    const [options, peerInfo, remainingAccounts] = await Promise.all([\n      this.createOptions({adapterParams, dstChainKey}),\n      this.getPeerInfo(connection, peer),\n      this.getQuoteAccounts(srcChainKey, input.srcAddress, dstEid),\n    ]);\n\n    const quote = await OftTools.quoteWithUln(\n      // Getting error saying that Connection isn't assignable to Connection from the same package\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      connection as any,\n      payer,\n      tokenMint,\n      dstEid,\n      amountLd,\n      minAmountLd,\n      options.toBytes(),\n      Array.from(to),\n      payInLzToken,\n      tokenEscrow,\n      composeMsg,\n      peerInfo.address,\n      remainingAccounts,\n      tokenProgramId,\n      oftProgramId,\n    );\n\n    return MessageFee.from(srcChainKey, {nativeFee: quote.nativeFee, zroFee: quote.lzTokenFee});\n  }\n\n  public async createOptions({\n    adapterParams,\n    dstChainKey,\n  }: {\n    adapterParams: AdapterParams;\n    dstChainKey: ChainKey;\n  }) {\n    return createOptions({adapterParams, dstChainKey}, this.config);\n  }\n\n  async getOutput(input: GetOutputInput): Promise<BridgeOutput<OftBridgeFee>> {\n    assert(input.srcAddress, 'srcAddress is required');\n    assert(input.dstAddress, 'dstAddress is required');\n    assert(input.srcAmount, 'srcAmount is required');\n    assert(input.dstAmountMin, 'dstAmountMin is required');\n    assert(input.adapterParams, 'adapterParams is required');\n\n    const srcToken = input.srcAmount.token;\n    const dstToken = input.dstToken;\n    const quote = await this.quoteOft({\n      srcAddress: input.srcAddress,\n      dstAddress: input.dstAddress,\n      srcAmount: input.srcAmount,\n      dstAmountMin: input.dstAmountMin,\n      adapterParams: input.adapterParams,\n    });\n\n    const dstAmount = castCurrencyAmountUnsafe(quote.oftReceipt.amountReceivedLd, dstToken);\n    const bridgeFeeBigInt = quote.oftFeeDetails.reduce(\n      (acc, value) => acc + value.feeAmountLd.toBigInt(),\n      0n,\n    );\n    const bridgeFee = CurrencyAmount.fromBigInt(srcToken, bridgeFeeBigInt);\n\n    return {\n      dstAmount,\n      fee: {\n        bridgeFee,\n      },\n    };\n  }\n\n  getDuration(input: GetDurationInput): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  async getLimit(input: GetLimitInput): Promise<CurrencyAmount<Currency>> {\n    assert(input.srcAddress, 'srcAddress is required');\n    assert(input.dstAddress, 'dstAddress is required');\n    assert(input.srcAmount, 'srcAmount is required');\n    assert(input.dstAmountMin, 'dstAmountMin is required');\n    assert(input.adapterParams, 'adapterParams is required');\n    const quote = await this.quoteOft({\n      srcAddress: input.srcAddress,\n      dstAddress: input.dstAddress,\n      srcAmount: input.srcAmount,\n      dstAmountMin: input.dstAmountMin,\n      adapterParams: input.adapterParams,\n    });\n\n    return quote.oftLimits.maxAmountLd;\n  }\n\n  protected async quoteOft(input: {\n    srcAddress: string;\n    dstAddress: string;\n    srcAmount: CurrencyAmount<Currency>;\n    dstAmountMin: CurrencyAmount<Currency>;\n    adapterParams: AdapterParams;\n  }) {\n    this.logger?.log('quoteOft', input);\n    const srcToken = input.srcAmount.token;\n    const dstToken = input.dstAmountMin.token;\n    const srcChainKey = srcToken.chainKey;\n    const dstChainKey = dstToken.chainKey;\n    const srcAddress = input.srcAddress;\n    const dstAddress = input.dstAddress;\n    const deployment = this.getDeployment(srcChainKey);\n    assert(isToken(deployment.token), 'Token address is required');\n    const payer = new PublicKey(srcAddress);\n    const tokenMint = new PublicKey(deployment.token.address);\n    const dstEid = this.chainKeyToEndpointId(dstChainKey);\n    const amountLd = input.srcAmount.toBigInt();\n    const minAmountLd = BigInt(0);\n    const to = addressToBytes32(dstAddress);\n    const tokenEscrow = deployment.tokenEscrow\n      ? new PublicKey(deployment.tokenEscrow.address)\n      : undefined;\n    const connection = this.getConnection(srcChainKey);\n\n    const adapterParams = AdapterParams.forV1(0);\n    const options = await this.createOptions({adapterParams, dstChainKey});\n    const payInLzToken = false;\n    const composeMsg = undefined;\n    const tokenProgramId = this.getTokenProgramId(srcChainKey);\n    const oftProgramId = this.getOftProgramId(srcChainKey);\n    const {oftLimits, oftReceipt, oftFeeDetails} = await OftTools.quoteOft(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      connection as any,\n      payer,\n      tokenMint,\n      dstEid,\n      amountLd,\n      minAmountLd,\n      options.toBytes(),\n      Array.from(to),\n      payInLzToken,\n      tokenEscrow,\n      composeMsg,\n      tokenProgramId,\n      oftProgramId,\n    );\n    const ld = (amount: string) => CurrencyAmount.fromBigInt(srcToken, BigInt(amount));\n\n    return {\n      oftLimits: {\n        minAmountLd: ld(oftLimits.minAmountLd.toString()),\n        maxAmountLd: ld(oftLimits.maxAmountLd.toString()),\n      },\n      oftReceipt: {\n        amountReceivedLd: ld(oftReceipt.amountReceivedLd.toString()),\n        amountSentLd: ld(oftReceipt.amountSentLd.toString()),\n      },\n      oftFeeDetails: oftFeeDetails.map((value) => ({\n        description: value.description,\n        feeAmountLd: ld(value.feeAmountLd.toString()),\n      })),\n    };\n  }\n\n  async getExtraGas(input: GetExtraGasInput): Promise<number> {\n    // gas is set by enforced options\n    return 0;\n  }\n  async getAllowance({token}: GetAllowanceInput): Promise<CurrencyAmount<Currency>> {\n    // solana doesn't need approve\n    return CurrencyAmount.fromRawAmount(token, MaxUint256);\n  }\n  async getOptions(input: GetOptionsInput): Promise<BridgeOptions> {\n    const taxiOption: BridgeOption = {\n      mode: 'taxi',\n    };\n    return {options: [taxiOption]};\n  }\n\n  async getUnclaimed({token}: GetUnclaimedInput): Promise<CurrencyAmount<Currency>> {\n    return CurrencyAmount.fromRawAmount(token, 0);\n  }\n  async isRegistered(input: IsRegisteredInput): Promise<boolean> {\n    // todo: check if need to verify rent\n    return true;\n  }\n  async transfer(input: TransferInput): Promise<Transaction<SolanaSigner>> {\n    validateInput(input);\n    const payer = new PublicKey(input.srcAddress);\n    const {srcChainKey} = input;\n    const connection = this.getConnection(srcChainKey);\n\n    const transactionInstruction = await this.getTransactionInstruction(input);\n    const computeUnitsLimit = await this.getComputeUnitsLimit(\n      connection,\n      transactionInstruction,\n      input,\n    );\n    const computeUnitsBudgetInstruction = ComputeBudgetProgram.setComputeUnitLimit({\n      units: computeUnitsLimit,\n    });\n\n    const versionedTransaction = await buildVersionedTransaction(connection, payer, [\n      computeUnitsBudgetInstruction,\n      transactionInstruction,\n    ]);\n\n    return createTransaction(versionedTransaction, {connection});\n  }\n  claim(input: ClaimInput): Promise<Transaction<SolanaSigner>> {\n    throw new Error('Method not implemented.');\n  }\n  register(register: RegisterInput): Promise<Transaction<SolanaSigner>> {\n    throw new Error('Method not implemented.');\n  }\n  approve(input: ApproveInput): Promise<Transaction<SolanaSigner>> {\n    throw new Error('Method not implemented.');\n  }\n\n  protected async getTransactionInstruction(\n    input: Required<TransferInput>,\n  ): Promise<TransactionInstruction> {\n    const deployment = this.getDeployment(input.srcChainKey);\n    assert(isToken(deployment.token), 'Token address is required');\n    const payer = new PublicKey(input.srcAddress);\n    const tokenMint = new PublicKey(deployment.token.address);\n    const tokenSource = await getAssociatedTokenAddress(tokenMint, payer);\n    const srcChainKey = input.srcToken.chainKey;\n    const dstChainKey = input.dstToken.chainKey;\n    const dstEid = this.chainKeyToEndpointId(dstChainKey);\n    const amountLd = input.srcAmount.toBigInt();\n    const minAmountLd = castCurrencyAmountUnsafe(input.dstAmountMin, input.srcToken).toBigInt();\n    const to = addressToBytes32(input.dstAddress);\n    const nativeFee = input.fee.nativeFee.toBigInt();\n    const lzTokenFee = input.fee.zroFee.toBigInt();\n    const tokenEscrow = deployment.tokenEscrow\n      ? new PublicKey(deployment.tokenEscrow.address)\n      : undefined;\n    const composeMsg = undefined;\n    const {adapterParams} = input;\n    const options = await this.createOptions({adapterParams, dstChainKey});\n\n    const connection = this.getConnection(srcChainKey);\n    const peer = this.getPeer(srcChainKey, dstEid);\n    const peerInfo = await this.getPeerInfo(connection, peer);\n\n    const remainingAccounts = await this.getSendAccounts(srcChainKey, input.srcAddress, dstEid);\n\n    const tokenProgramId = this.getTokenProgramId(srcChainKey);\n    const oftProgramId = this.getOftProgramId(srcChainKey);\n\n    const transactionInstruction = await OftTools.sendWithUln(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      connection as any,\n      payer,\n      tokenMint,\n      tokenSource,\n      dstEid,\n      amountLd,\n      minAmountLd,\n      options.toBytes(),\n      Array.from(to),\n      nativeFee,\n      lzTokenFee,\n      tokenEscrow,\n      composeMsg,\n      peerInfo.address,\n      remainingAccounts,\n      tokenProgramId,\n      oftProgramId,\n    );\n    return transactionInstruction;\n  }\n\n  // extracted so it can be cached (reduce RPC calls)\n  protected getPeerInfo(connection: Connection, peer: PublicKey) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return OftProgram.accounts.Peer.fromAccountAddress(connection as any, peer);\n  }\n\n  protected getPeer(srcChainKey: ChainKey, dstEid: number): PublicKey {\n    const oftInstance = this.getOftInstance(srcChainKey);\n    const deriver = this.getDeriver(srcChainKey);\n    const peer = deriver.peer(oftInstance, dstEid);\n    return peer[0];\n  }\n\n  protected async getComputeUnitsLimit(\n    connection: Connection,\n    transactionInstruction: TransactionInstruction,\n    input: TransferInput,\n  ): Promise<number> {\n    const payer = new PublicKey(input.srcAddress);\n    const simulationComputeUnits = await getSimulationComputeUnits(\n      connection,\n      [transactionInstruction],\n      payer,\n      [],\n    );\n    const computeUnitsLimit =\n      simulationComputeUnits === null\n        ? 1000\n        : simulationComputeUnits < 1000\n          ? 1000\n          : Math.ceil(simulationComputeUnits * 1.5);\n\n    return computeUnitsLimit;\n  }\n\n  protected tryGetDeployment(chainKey: ChainKey) {\n    return this.config.deployments[chainKey];\n  }\n\n  protected getDeployment(chainKey: ChainKey) {\n    const deployment = this.tryGetDeployment(chainKey);\n    if (deployment) return deployment;\n    throw new Error(`Deployment not found for chainKey ${chainKey}`);\n  }\n\n  protected chainKeyToEndpointId(chainKey: string): number {\n    const deployment = this.getDeployment(chainKey);\n    return deployment.eid;\n  }\n}\n\nexport async function buildMessageV0(\n  connection: Connection,\n  payerKey: PublicKey,\n  instructions: TransactionInstruction[],\n  commitmentOrConfig?: Commitment | GetAccountInfoConfig,\n  lookupTableAddresses?: AddressLookupTableAccount[],\n): Promise<MessageV0> {\n  return new TransactionMessage({\n    payerKey: payerKey,\n    recentBlockhash: await connection\n      .getLatestBlockhash(commitmentOrConfig)\n      .then((res) => res.blockhash),\n    instructions: instructions,\n  }).compileToV0Message(lookupTableAddresses);\n}\n\nexport async function buildVersionedTransaction(\n  connection: Connection,\n  payerKey: PublicKey,\n  instructions: TransactionInstruction[],\n  commitmentOrConfig?: Commitment | GetAccountInfoConfig,\n  lookupTableAddresses?: AddressLookupTableAccount[],\n): Promise<VersionedTransaction> {\n  return new VersionedTransaction(\n    await buildMessageV0(\n      connection,\n      payerKey,\n      instructions,\n      commitmentOrConfig,\n      lookupTableAddresses,\n    ),\n  );\n}\n"]}
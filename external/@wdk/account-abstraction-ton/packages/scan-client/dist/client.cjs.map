{"version":3,"sources":["../src/client.ts"],"names":["MessageStatus","httpClient"],"mappings":";AAAA,OAAO,gBAAgB;AAQhB,IAAK,gBAAL,kBAAKA,mBAAL;AACL,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,eAAY;AACZ,EAAAA,eAAA,YAAS;AAHC,SAAAA;AAAA,GAAA;AAoBZ,IAAM,OAA8B;AAAA,EAClC,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AACX;AAYO,IAAM,aAAN,MAAiB;AAAA,EAatB,YAAsB,QAA0B;AAA1B;AACpB,QAAI,CAAC,OAAO,WAAW,CAAC,OAAO,WAAW,CAAC,OAAO,SAAS;AACzD,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AACA,QAAI,KAAK,OAAO;AAAS,WAAK,QAAQ,KAAK,KAAK,OAAO;AACvD,QAAI,KAAK,OAAO;AAAS,WAAK,QAAQ,KAAK,KAAK,OAAO;AACvD,QAAI,KAAK,OAAO;AAAS,WAAK,QAAQ,KAAK,KAAK,OAAO;AAAA,EACzD;AAAA,EAnBU,UAAU,WAAW,OAAO;AAAA,IACpC,SAAS,KAAK;AAAA,EAChB,CAAC;AAAA,EACS,UAAU,WAAW,OAAO;AAAA,IACpC,SAAS,KAAK;AAAA,EAChB,CAAC;AAAA,EACS,UAAU,WAAW,OAAO;AAAA,IACpC,SAAS,KAAK;AAAA,EAChB,CAAC;AAAA,EAES,UAAgC,CAAC;AAAA,EAW3C,yBAAyB,OAAO,cAA0C;AACxE,QAAI,CAAC;AAAW,YAAM,IAAI,MAAM,4BAA4B;AAE5D,UAAM,WAAW,MAAM,QAAQ;AAAA,MAC7B,KAAK,QAAQ,IAAI,CAAC,WAAW,uBAAuB,QAAQ,SAAS,CAAC;AAAA,IACxE;AAEA,WAAO,SAAS,QAAQ,CAAC,MAAM,EAAE,QAAQ;AAAA,EAC3C;AAAA,EAEA,yBAAyB,OACvB,EAAC,QAAQ,UAAS,GAClB,EAAC,QAAQ,eAAe,IAAI,MACE;AAC9B,QAAI,CAAC;AAAW,YAAM,IAAI,MAAM,8CAA8C;AAE9E,UAAM,kBAAkB,IAAI,gBAAgB;AAE5C,UAAM,cAAc,gBAAgB;AAEpC,QAAI,QAAQ;AACV,aAAO,iBAAiB,SAAS,MAAM;AACrC,wBAAgB,MAAM,OAAO,MAAM;AAAA,MACrC,CAAC;AAAA,IACH;AAEA,mBAAe,KAAK,QAA4B;AAC9C,aAAO,CAAC,YAAY,SAAS;AAC3B,YAAI;AACF,gBAAM,EAAC,SAAQ,IAAI,MAAM,uBAAuB,QAAQ,SAAS;AACjE,gBAAM,UAAU,SAAS,CAAC;AAC1B,cAAI,SAAS,SAAS,GAAG;AACvB,kBAAM,IAAI,MAAM,yBAAyB,EAAC,OAAO,EAAC,SAAQ,EAAC,CAAC;AAAA,UAC9D,WAAW,SAAS,WAAW,uBAAsB;AACnD,kBAAM,IAAI,MAAM,kBAAkB,QAAQ,cAAc,EAAC,OAAO,EAAC,QAAO,EAAC,CAAC;AAAA,UAC5E,WAAW,SAAS,WAAW,6BAAyB;AACtD,mBAAO;AAAA,UACT;AAAA,QACF,QAAE;AAAA,QAEF;AACA,cAAM,MAAM,YAAY;AAAA,MAC1B;AACA,YAAM,IAAI,MAAM,WAAW,EAAC,OAAO,YAAY,OAAM,CAAC;AAAA,IACxD;AAEA,WAAO,QAAQ,KAAK,KAAK,QAAQ,IAAI,CAAC,WAAW,KAAK,MAAM,CAAC,CAAC,EAAE,QAAQ,MAAM;AAC5E,sBAAgB,MAAM;AAAA,IACxB,CAAC;AAAA,EACH;AACF;AAEA,eAAe,uBAAuBC,aAAgC,WAAmB;AACvF,QAAM,EAAC,KAAI,IAAI,MAAMA,YAAW,IAAoC,OAAO,WAAW;AACtF,SAAO;AACT;AAIA,IAAM,QAAQ,CAAC,KAAK,QAAS,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC","sourcesContent":["import httpClient from 'redaxios';\n\ntype HttpClientInstance = ReturnType<typeof httpClient.create>;\n\nexport type Stage = 'testnet' | 'mainnet' | 'sandbox';\n\nexport type ClientOptions = {};\n\nexport enum MessageStatus {\n  INFLIGHT = 'INFLIGHT',\n  DELIVERED = 'DELIVERED',\n  FAILED = 'FAILED',\n}\n\nexport type Message = {\n  srcUaAddress: string;\n  dstUaAddress: string;\n  srcChainId: number;\n  dstChainId: number;\n  dstTxHash?: string;\n  dstTxError?: string;\n  srcTxHash?: string;\n  srcBlockHash?: string;\n  srcBlockNumber?: string;\n  srcUaNonce: number;\n  status: MessageStatus;\n};\n\nconst URLS: Record<Stage, string> = {\n  testnet: 'https://api-testnet.layerzero-scan.com',\n  mainnet: 'https://api-mainnet.layerzero-scan.com',\n  sandbox: 'https://api-sandbox.layerzero-scan.com',\n};\n\ntype GetMessagesBySrcTxHashResponse = {\n  messages: Message[];\n};\n\ntype ScanClientConfig = {\n  mainnet?: boolean;\n  testnet?: boolean;\n  sandbox?: boolean;\n};\n\nexport class ScanClient {\n  protected mainnet = httpClient.create({\n    baseURL: URLS.mainnet,\n  });\n  protected testnet = httpClient.create({\n    baseURL: URLS.testnet,\n  });\n  protected sandbox = httpClient.create({\n    baseURL: URLS.sandbox,\n  });\n\n  protected clients: HttpClientInstance[] = [];\n\n  constructor(protected config: ScanClientConfig) {\n    if (!config.mainnet && !config.testnet && !config.sandbox) {\n      throw new Error('At least one stage must be enabled');\n    }\n    if (this.config.mainnet) this.clients.push(this.mainnet);\n    if (this.config.testnet) this.clients.push(this.testnet);\n    if (this.config.sandbox) this.clients.push(this.sandbox);\n  }\n\n  getMessagesBySrcTxHash = async (srcTxHash: string): Promise<Message[]> => {\n    if (!srcTxHash) throw new Error('srcTxHash must be provided');\n\n    const messages = await Promise.all(\n      this.clients.map((client) => getMessagesBySrcTxHash(client, srcTxHash)),\n    );\n\n    return messages.flatMap((m) => m.messages);\n  };\n\n  waitForMessageReceived = async (\n    {txHash: srcTxHash}: {txHash: string},\n    {signal, poolInterval = 3000}: {signal?: AbortSignal; poolInterval: number},\n  ): Promise<DeliveredMessage> => {\n    if (!srcTxHash) throw new Error('Invalid transaction: txHash must be provided');\n\n    const abortController = new AbortController();\n\n    const abortSignal = abortController.signal;\n\n    if (signal) {\n      signal.addEventListener('abort', () => {\n        abortController.abort(signal.reason);\n      });\n    }\n\n    async function poll(client: HttpClientInstance) {\n      while (!abortSignal.aborted) {\n        try {\n          const {messages} = await getMessagesBySrcTxHash(client, srcTxHash);\n          const message = messages[0];\n          if (messages.length > 1) {\n            throw new Error(`More than one message`, {cause: {messages}});\n          } else if (message?.status === MessageStatus.FAILED) {\n            throw new Error(`Message failed ${message.dstTxError}`, {cause: {message}});\n          } else if (message?.status === MessageStatus.DELIVERED) {\n            return message as DeliveredMessage;\n          }\n        } catch {\n          // http error\n        }\n        await sleep(poolInterval);\n      }\n      throw new Error('Aborted', {cause: abortSignal.reason});\n    }\n\n    return Promise.race(this.clients.map((client) => poll(client))).finally(() => {\n      abortController.abort();\n    });\n  };\n}\n\nasync function getMessagesBySrcTxHash(httpClient: HttpClientInstance, srcTxHash: string) {\n  const {data} = await httpClient.get<GetMessagesBySrcTxHashResponse>(`/tx/${srcTxHash}`);\n  return data;\n}\n\ntype DeliveredMessage = Message & {dstTxHash: string};\n\nconst sleep = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));\n"]}
{"version":3,"sources":["../src/utils/isSolanaAddress.ts","../src/utils/createTransaction.ts","../src/utils/helpers.ts","../src/providers/BalanceProvider__solana.ts"],"names":["PublicKey"],"mappings":"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","sourcesContent":["const solanaAddressRegex = /^([1-9A-HJ-NP-Za-km-z]{32,44})$/;\n\nexport function isSolanaAddress(address: string): boolean {\n  return solanaAddressRegex.test(address);\n}\n","import type {Transaction} from '@layerzerolabs/ui-core';\nimport type {SolanaSigner, SolanaSubmitOptions, SolanaTransaction} from '../SolanaSigner';\n\nexport function createTransaction(\n  populatedTransaction: SolanaTransaction,\n  options: SolanaSubmitOptions,\n): Transaction<SolanaSigner> {\n  return {\n    async unwrap() {\n      return populatedTransaction;\n    },\n    estimateGas() {\n      throw new Error('Not implemented');\n    },\n    async signAndSubmitTransaction(signer) {\n      const latestBlockHash = await options.connection.getLatestBlockhashAndContext();\n      const signedTransaction = await signer.signTransaction(populatedTransaction, {});\n      const signature = await options.connection.sendRawTransaction(signedTransaction.serialize());\n      return {\n        txHash: signature,\n        async wait() {\n          const confirmation = await options.connection.confirmTransaction(\n            {\n              signature: signature,\n              blockhash: latestBlockHash.value.blockhash,\n              lastValidBlockHeight: latestBlockHash.value.lastValidBlockHeight,\n            },\n            'confirmed',\n          );\n          const error = confirmation.value.err;\n          if (error) {\n            throw new Error(`Confirmation of transaction ${signature} failed`, {cause: error});\n          }\n          return {\n            txHash: signature,\n          };\n        },\n      };\n    },\n    estimateNative() {\n      throw new Error('Not implemented');\n    },\n  };\n}\n","// TODO: remove when https://github.com/solana-developers/helpers/pull/35 gets merged\n\n// copy of @/solana-developers/helpers\n// https://github.com/solana-developers/helpers\n// original package has fs/promises dependency that is not supported in the browser\n\nimport {\n  type Connection,\n  type TransactionInstruction,\n  PublicKey,\n  type AddressLookupTableAccount,\n  ComputeBudgetProgram,\n  VersionedTransaction,\n  TransactionMessage,\n  type RpcResponseAndContext,\n  type SignatureResult,\n  type SimulatedTransactionResponse,\n} from '@solana/web3.js';\n\nexport const getErrorFromRPCResponse = (\n  rpcResponse: RpcResponseAndContext<SignatureResult | SimulatedTransactionResponse>,\n) => {\n  // Note: `confirmTransaction` does not throw an error if the confirmation does not succeed,\n  // but rather a `TransactionError` object. so we handle that here\n  // See https://solana-labs.github.io/solana-web3.js/classes/Connection.html#confirmTransaction.confirmTransaction-1\n\n  const error = rpcResponse.value.err;\n  if (error) {\n    // Can be a string or an object (literally just {}, no further typing is provided by the library)\n    // https://github.com/solana-labs/solana-web3.js/blob/4436ba5189548fc3444a9f6efb51098272926945/packages/library-legacy/src/connection.ts#L2930\n    // TODO: if still occurs in web3.js 2 (unlikely), fix it.\n    if (typeof error === 'object') {\n      const errorKeys = Object.keys(error);\n      if (errorKeys.length === 1) {\n        if (errorKeys[0] !== 'InstructionError') {\n          throw new Error(`Unknown RPC error: ${error}`);\n        }\n        // @ts-ignore due to missing typing information mentioned above.\n        const instructionError = error['InstructionError'];\n        // An instruction error is a custom program error and looks like:\n        // [\n        //   1,\n        //   {\n        //     \"Custom\": 1\n        //   }\n        // ]\n        // See also https://solana.stackexchange.com/a/931/294\n        throw new Error(\n          `Error in transaction: instruction index ${instructionError[0]}, custom program error ${instructionError[1]['Custom']}`,\n        );\n      }\n    }\n    throw Error(error.toString());\n  }\n};\n\n// Was getSimulationUnits\n// Credit https://twitter.com/stegabob, originally from\n\n// https://x.com/stegaBOB/status/1766662289392889920\nexport const getSimulationComputeUnits = async (\n  connection: Connection,\n  instructions: Array<TransactionInstruction>,\n  payer: PublicKey,\n  lookupTables: Array<AddressLookupTableAccount> | [],\n): Promise<number | null> => {\n  const testInstructions = [\n    // Set an arbitrarily high number in simulation\n    // so we can be sure the transaction will succeed\n    // and get the real compute units used\n    ComputeBudgetProgram.setComputeUnitLimit({units: 1_400_000}),\n    ...instructions,\n  ];\n\n  const testTransaction = new VersionedTransaction(\n    new TransactionMessage({\n      instructions: testInstructions,\n      payerKey: payer,\n      // RecentBlockhash can by any public key during simulation\n      // since 'replaceRecentBlockhash' is set to 'true' below\n      recentBlockhash: PublicKey.default.toString(),\n    }).compileToV0Message(lookupTables),\n  );\n\n  const rpcResponse = await connection.simulateTransaction(testTransaction, {\n    replaceRecentBlockhash: true,\n    sigVerify: false,\n  });\n\n  getErrorFromRPCResponse(rpcResponse);\n  return rpcResponse.value.unitsConsumed || null;\n};\n","import {\n  type BalanceProvider,\n  type Currency,\n  CurrencyAmount,\n  isToken,\n  isSolanaChainKey,\n  isNativeCurrency,\n  type Token,\n  assert,\n} from '@layerzerolabs/ui-core';\nimport {TOKEN_PROGRAM_ID} from '@solana/spl-token';\nimport {PublicKey, type Connection} from '@solana/web3.js';\nimport memoize from 'moize';\n\nexport class BalanceProvider__solana implements BalanceProvider {\n  constructor(\n    private readonly connection: Connection,\n    protected config: {\n      // in ms, default 4_000\n      cacheTime?: number;\n      // in ms, default 1_000\n      cacheSize?: number;\n    } = {},\n  ) {\n    const options = Object.assign({\n      isPromise: true,\n      updateExpire: true,\n      maxSize: config.cacheSize ?? 1_000,\n      maxAge: config.cacheTime ?? 4_000,\n    });\n    this.getTokenBalancesByMint = memoize(this.getTokenBalancesByMint.bind(this), options);\n    this.getNativeBalance = memoize(this.getNativeBalance.bind(this), options);\n  }\n\n  supports(token: Currency): boolean {\n    return isSolanaChainKey(token.chainKey);\n  }\n\n  protected async getTokenBalancesByMint(address: string) {\n    const userPublicKey = new PublicKey(address);\n    const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(userPublicKey, {\n      programId: TOKEN_PROGRAM_ID,\n    });\n\n    // groupBy mint\n    const result = Object.fromEntries(\n      tokenAccounts.value.map((value) => [\n        value.account.data.parsed.info.mint,\n        value.account.data.parsed,\n      ]),\n    );\n    return result as Record<string, ParsedData>;\n  }\n\n  protected async getTokenBalance(token: Token, address: string): Promise<CurrencyAmount> {\n    const tokenBalances = await this.getTokenBalancesByMint(address);\n    const balance = tokenBalances[token.address];\n    if (balance === undefined) {\n      return CurrencyAmount.fromRawAmount(token, 0);\n    }\n    if (balance.info.tokenAmount.decimals !== token.decimals) {\n      // check decimals to prevent unexpected behavior\n      throw new Error(\n        `Token decimals mismatch: expected ${token.decimals}, got ${balance.info.tokenAmount.decimals}`,\n        {cause: {token, balance}},\n      );\n    }\n    return CurrencyAmount.fromRawAmount(token, balance.info.tokenAmount.amount);\n  }\n\n  async getBalance(currency: Currency, address: string): Promise<CurrencyAmount> {\n    if (isNativeCurrency(currency)) {\n      const amount = await this.getNativeBalance(address);\n      return CurrencyAmount.fromRawAmount(currency, amount);\n    }\n    assert(isToken(currency));\n    return this.getTokenBalance(currency, address);\n  }\n\n  protected async getNativeBalance(address: string): Promise<number> {\n    const userPublicKey = new PublicKey(address);\n    return this.connection.getBalance(userPublicKey);\n  }\n}\n\ninterface ParsedData {\n  type: 'account' | string;\n  info: {\n    isNative: boolean;\n    mint: string;\n    owner: string;\n    state: 'initialized' | string;\n    tokenAmount: {\n      amount: string;\n      decimals: number;\n    };\n  };\n}\n"]}
{"version":3,"sources":["../src/providers/BalanceProvider__ton.ts","../src/utils.ts","../src/wrappers/BaseWrapper.ts","../src/wrappers/TonContractWrapper.ts","../src/wrappers/UsdtMinter.ts","../src/wrappers/UsdtWallet.ts","../src/wrappers/TonBaseMinter.ts","../src/getJettonAddressFromWallet.ts","../src/createTransaction.ts","../src/computeContractAddress.ts","../src/TransactionTrace.ts"],"names":["beginCell","SendMode","Cell","Slice","contractAddress","toBigIntBE","emptyCell","bigintToAsciiString","clGetUint","trimStart"],"mappings":"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","sourcesContent":["import {TonClient} from '@ton/ton';\nimport {\n  BalanceProvider,\n  ChainType,\n  type Currency,\n  CurrencyAmount,\n  getNativeCurrency,\n  tryGetNetwork,\n} from '@layerzerolabs/ui-core';\nimport {parseTonAddress} from '../utils';\nimport {UsdtMinter, UsdtWallet} from '../wrappers';\nimport {getJettonAddressFromWallet} from '../getJettonAddressFromWallet';\n\nexport class BalanceProvider__ton implements BalanceProvider {\n  constructor(\n    private readonly client: TonClient,\n    private readonly minterAddress: string,\n  ) {}\n\n  async getBalance(token: Currency, address: string): Promise<CurrencyAmount> {\n    const tonWalletAddress = parseTonAddress(address);\n    if (token.symbol === 'TON') {\n      return CurrencyAmount.fromRawAmount(\n        getNativeCurrency(ChainType.TON),\n        await this.client.getBalance(parseTonAddress(address)),\n      );\n    }\n    return getJettonAddressFromWallet(this.getMinterContract(token), tonWalletAddress).then(\n      (jettonWalletAddress) => {\n        const provider = this.client.provider(jettonWalletAddress);\n        const walletContract = provider.open(UsdtWallet.createFromAddress(jettonWalletAddress));\n        return walletContract.getUsdtBalance().then((balance) => {\n          return CurrencyAmount.fromRawAmount(token, balance);\n        });\n      },\n    );\n  }\n\n  getMinterContract = (token: Currency) => {\n    if (token.symbol === 'USDT0' || token.symbol === 'USDT') {\n      const tonMinterAddress = parseTonAddress(this.minterAddress);\n      return this.client.open(UsdtMinter.createFromAddress(tonMinterAddress));\n    }\n    throw new Error('Unsupported token');\n  };\n\n  supports(token: Currency): boolean {\n    return tryGetNetwork(token.chainKey)?.chainType === ChainType.TON;\n  }\n}\n","import {toBigIntBE, toBufferBE} from 'bigint-buffer';\nimport {Address} from '@ton/ton';\nimport {trimStart} from 'lodash';\nimport {beginCell, Cell, Slice} from '@ton/core';\n\nfunction isHexString(value: any, length?: number): boolean {\n  if (typeof value !== 'string' || !value.match(/^(0x)?[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\n\nfunction to32ByteBuffer(\n  value: bigint | number | string | Uint8Array,\n  maxIntermediateBufferSize = 66,\n): Buffer {\n  if (typeof value === 'string') {\n    if (!isHexString(value)) {\n      throw new Error('only hex string is supported');\n    }\n    let hex = trimStart(value, '0x');\n    if (hex.length % 2 !== 0) {\n      hex = '0' + hex;\n    }\n    value = toBigIntBE(Buffer.from(hex, 'hex'));\n  }\n  if (value instanceof Uint8Array) {\n    value = toBigIntBE(Buffer.from(value));\n  }\n  const bf = toBufferBE(BigInt(value), maxIntermediateBufferSize);\n  // trim from the left, keep the right 32 bytes\n  return bf.subarray(-32);\n}\n\nexport function bigintToAddress(value: bigint): Address {\n  const buf = to32ByteBuffer(value);\n  return Address.parse(`0:${buf.toString('hex')}`);\n}\n\ntype AddressTypeLike = Address | string | bigint;\n\nexport const parseTonAddress = (address: AddressTypeLike) => {\n  if (address instanceof Address) {\n    return address;\n  }\n\n  if (typeof address === 'bigint' || typeof address === 'number') {\n    return bigintToAddress(BigInt(address));\n  }\n\n  if (address.startsWith('0x')) {\n    // If it's a hex address format it to ton format\n    return bigintToAddress(BigInt(address));\n  }\n\n  try {\n    return Address.parse(address);\n  } catch (e) {\n    // handles the case where the address is hex format without leading 0x\n    return bigintToAddress(BigInt(`0x${address}`));\n  }\n};\n\nexport const tonAddressToHex = (tonAddress: string) => {\n  parseTonAddress('kQAIO31lsBFFFxz8EaOaPcsorplKMZR1VPROiPY-9IOz2rzO').toRawString();\n};\n\nexport const arrayBufferToBase64 = (buffer: Buffer) => {\n  let binary = '';\n  let bytes = new Uint8Array(buffer);\n  let len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n};\n\nexport const buildTonTransferCell = (\n  opts: {\n    value: bigint;\n    fromAddress?: Address;\n    toAddress: Address;\n    queryId?: number;\n    fwdAmount: bigint;\n    jettonAmount: bigint;\n  } & (\n    | {\n        forwardPayload?: Cell | Slice | null;\n      }\n    | {\n        comment: string;\n      }\n  ),\n) => {\n  const builder = beginCell()\n    .storeUint(0xf8a7ea5, 32) // Transfer\n    .storeUint(opts.queryId ?? 69, 64)\n    .storeCoins(opts.jettonAmount)\n    .storeAddress(opts.toAddress)\n    .storeAddress(opts.fromAddress)\n    .storeUint(0, 1)\n    .storeCoins(opts.fwdAmount);\n\n  if ('comment' in opts) {\n    const commentPayload = beginCell().storeUint(0, 32).storeStringTail(opts.comment).endCell();\n\n    builder.storeBit(1);\n    builder.storeRef(commentPayload);\n  } else {\n    if (opts.forwardPayload instanceof Slice) {\n      builder.storeBit(0);\n      builder.storeSlice(opts.forwardPayload);\n    } else if (opts.forwardPayload instanceof Cell) {\n      builder.storeBit(1);\n      builder.storeRef(opts.forwardPayload);\n    } else {\n      builder.storeBit(0);\n    }\n  }\n  return builder.endCell();\n};\n\nconst _addressToNotPaddedHex = (address: AddressTypeLike): string => {\n  return `0x${parseTonAddress(address).hash.toString('hex')}`;\n};\nexport const addressToBigInt = (address: AddressTypeLike): bigint => {\n  return BigInt(_addressToNotPaddedHex(address));\n};\n\nexport const bigIntToAddress = (address: bigint): Address => {\n  return parseTonAddress('0x' + address.toString(16));\n};\n\nexport const emptyCell = (): Cell => {\n  return beginCell().asCell();\n};\n\nexport const asciiStringToBigint = (target: string): bigint => {\n  return BigInt(`0x${Buffer.from(target).toString('hex')}`);\n};\n","import {\n  Address,\n  Builder,\n  Cell,\n  Contract,\n  ContractProvider,\n  SendMode,\n  Sender,\n  SenderArguments,\n  beginCell,\n} from '@ton/core';\n\nexport interface SendRequestOptions {\n  value: number | bigint | string;\n  bounce?: boolean;\n  sendMode?: SendMode;\n  queryId?: number | bigint;\n  withInit?: boolean;\n}\n\nexport abstract class BaseWrapper implements Contract {\n  constructor(\n    readonly address: Address,\n    readonly init?: {code: Cell; data: Cell},\n  ) {}\n\n  async sendDeploy(provider: ContractProvider, via: Sender, value: bigint | string): Promise<void> {\n    await provider.internal(via, {\n      value,\n      sendMode: SendMode.PAY_GAS_SEPARATELY,\n      body: beginCell().endCell(),\n    });\n  }\n\n  async sendRequest(\n    provider: ContractProvider,\n    via: Sender,\n    request: SenderArguments,\n  ): Promise<void> {\n    return provider.internal(via, {\n      value: request.value,\n      sendMode: request.sendMode ?? undefined,\n      body: request.body,\n      bounce: request.bounce,\n    });\n  }\n\n  async getDeployed(provider: ContractProvider): Promise<boolean> {\n    const state = await provider.getState();\n    return state.state.type !== 'uninit';\n  }\n\n  buildSenderArguments(body: Cell, opts: SendRequestOptions): SenderArguments {\n    return {\n      value: BigInt(opts.value),\n      to: this.address,\n      bounce: opts.bounce ?? true,\n      body,\n      init: opts.withInit === true ? this.init : undefined,\n      sendMode: opts.sendMode ?? SendMode.PAY_GAS_SEPARATELY,\n    } satisfies SenderArguments;\n  }\n\n  beginMessage(opcode: number | bigint, queryId?: number | bigint): Builder {\n    const randomQueryId = Math.floor(Math.random() * 100000000000);\n    return beginCell()\n      .storeUint(opcode, 32)\n      .storeUint(queryId ?? randomQueryId, 64);\n  }\n}\n","import {Cell, ContractProvider, TupleItem, TupleReader} from '@ton/core';\nimport {Address} from '@ton/ton';\nimport {BaseWrapper} from './BaseWrapper';\n\nexport class TonContractWrapper extends BaseWrapper {\n  static create(address: Address): TonContractWrapper {\n    return new TonContractWrapper(address);\n  }\n\n  async getViewFunction(\n    provider: ContractProvider,\n    method: string,\n    args: TupleItem[],\n  ): Promise<TupleReader> {\n    const ret = await provider.get(method, args);\n    return ret.stack;\n  }\n\n  async getGetAmountAndFee(\n    provider: ContractProvider,\n    totalAmount: bigint,\n  ): Promise<[bigint, bigint]> {\n    const args: TupleItem[] = [{type: 'int', value: totalAmount}];\n    const stack = await this.getViewFunction(provider, 'getAmountAndFee', args);\n    return [stack.readBigNumber(), stack.readBigNumber()];\n  }\n\n  async getLzSendMd(provider: ContractProvider, oftSendMd: Cell) {\n    const args: TupleItem[] = [\n      {type: 'cell', cell: oftSendMd},\n      {type: 'int', value: 2n}, // Msg type. 2 is SEND_OFT\n    ];\n    const stack = await this.getViewFunction(provider, 'getLzSendMd', args);\n    return stack.readCell();\n  }\n\n  async getGetAllCredits(\n    provider: ContractProvider,\n  ): Promise<[bigint, bigint, bigint, bigint, bigint]> {\n    const args: TupleItem[] = [];\n    const stack = await this.getViewFunction(provider, 'getAllCredits', args);\n\n    // Arbitrum, Celo, Eth, Ton, Tron\n    return [\n      stack.readBigNumber(),\n      stack.readBigNumber(),\n      stack.readBigNumber(),\n      stack.readBigNumber(),\n      stack.readBigNumber(),\n    ];\n  }\n\n  async parseSendInfo(\n    provider: ContractProvider,\n    cell: Cell,\n  ): Promise<[bigint, bigint, bigint, bigint, bigint]> {\n    const _dstEidOffset = 0;\n    const _toOffset = _dstEidOffset + 32;\n    const _minAmountOffset = _toOffset + 256;\n    const _nativeFeeOffset = _minAmountOffset + 128;\n    const _zroFeeOffset = _nativeFeeOffset + 128;\n    const selfSlice = cell.beginParse();\n\n    const skipTo = (offset: number) => {\n      if (selfSlice.offsetBits < offset) {\n        selfSlice.skip(offset - selfSlice.offsetBits);\n      }\n    };\n\n    const dstEid = selfSlice.loadUintBig(32);\n    // skipTo(_toOffset);\n    const to = selfSlice.loadUintBig(256);\n    // skipTo(_minAmountOffset);\n    const minAmount = selfSlice.loadCoins();\n    // skipTo(_nativeFeeOffset);\n    const nativeFee = selfSlice.loadCoins();\n    // skipTo(_zroFeeOffset);\n    const zroFee = selfSlice.loadCoins();\n\n    return [dstEid, to, minAmount, nativeFee, zroFee];\n  }\n\n  async getNewUsdtOFT(\n    provider: ContractProvider,\n    args: {\n      owner: bigint;\n      controllerAddress: bigint;\n      eid: bigint;\n      endpointCode: Cell;\n      channelCode: Cell;\n    },\n  ): Promise<Cell> {\n    const getResult = await provider.get('UsdtOFT::New', [\n      {type: 'int', value: args.owner},\n      {type: 'int', value: args.controllerAddress},\n      {type: 'int', value: args.eid},\n      {type: 'cell', cell: args.endpointCode},\n      {type: 'cell', cell: args.channelCode},\n    ]);\n    return getResult.stack.readCell();\n  }\n\n  async getNewOFTSend(\n    provider: ContractProvider,\n    args: {\n      dstEid: bigint;\n      to: bigint;\n      minAmount: bigint;\n      nativeFee: bigint;\n      zroFee: bigint;\n      extraOptions: Cell;\n      composeMessage: Cell;\n    },\n  ): Promise<Cell> {\n    const getResult = await provider.get('OFTSend::New', [\n      {type: 'int', value: args.dstEid},\n      {type: 'int', value: args.to},\n      {type: 'int', value: args.minAmount},\n      {type: 'int', value: args.nativeFee},\n      {type: 'int', value: args.zroFee},\n      {type: 'cell', cell: args.extraOptions},\n      {type: 'cell', cell: args.composeMessage},\n    ]);\n    return getResult.stack.readCell();\n  }\n\n  async createExtraOptions(\n    provider: ContractProvider,\n    args: {\n      lzReceiveGas: bigint;\n      lzReceiveValue: bigint;\n      nativeDropAddress: bigint; // Hex string as number. Can be done via BigInt(address)\n      nativeDropAmount: bigint;\n    },\n  ): Promise<Cell> {\n    const getResult = await provider.get('md::OptionsV1::New', [\n      {type: 'int', value: args.lzReceiveGas},\n      {type: 'int', value: args.lzReceiveValue},\n      {type: 'int', value: args.nativeDropAddress},\n      {type: 'int', value: args.nativeDropAmount},\n    ]);\n    return getResult.stack.readCell();\n  }\n}\n","import {\n  Address,\n  Cell,\n  ContractProvider,\n  SendMode,\n  Sender,\n  TupleBuilder,\n  beginCell,\n  contractAddress,\n} from '@ton/core';\nimport {TonBaseMinter} from './TonBaseMinter';\n\nexport interface MinterConfig {\n  total_supply: bigint;\n  admin_address: Address;\n  next_admin_address: Address;\n  jetton_wallet_code: Cell;\n  metadata_url: Cell;\n}\n\nexport function minterConfigToCell(config: MinterConfig): Cell {\n  return beginCell()\n    .storeCoins(config.total_supply)\n    .storeAddress(config.admin_address)\n    .storeAddress(config.next_admin_address)\n    .storeRef(config.jetton_wallet_code)\n    .storeRef(config.metadata_url)\n    .endCell();\n}\n\nexport const Opcodes = {\n  mint: 0x642b7d07,\n  burn_notification: 0x7bdd97de,\n  deposit: 0x23db01c5,\n  withdraw: 0x163e135,\n};\n\nexport class UsdtMinter implements TonBaseMinter {\n  constructor(\n    readonly address: Address,\n    readonly init?: {code: Cell; data: Cell},\n  ) {}\n\n  static createFromAddress(address: Address): UsdtMinter {\n    return new UsdtMinter(address);\n  }\n\n  static createFromConfig(config: MinterConfig, code: Cell, workchain = 0): UsdtMinter {\n    const data = minterConfigToCell(config);\n    const init = {code, data};\n    return new UsdtMinter(contractAddress(workchain, init), init);\n  }\n\n  async sendDeploy(provider: ContractProvider, via: Sender, value: bigint): Promise<void> {\n    await provider.internal(via, {\n      value,\n      sendMode: SendMode.PAY_GAS_SEPARATELY,\n      body: beginCell().endCell(),\n    });\n  }\n\n  async sendMint(\n    provider: ContractProvider,\n    via: Sender,\n    opts: {\n      value: bigint | string;\n      queryID?: number;\n      toAddress: Address;\n      tonAmount: bigint;\n      master_msg: Cell;\n    },\n  ): Promise<void> {\n    await provider.internal(via, {\n      value: opts.value,\n      sendMode: SendMode.PAY_GAS_SEPARATELY,\n      body: beginCell()\n        .storeUint(Opcodes.mint, 32)\n        .storeUint(opts.queryID ?? 0, 64)\n        .storeAddress(opts.toAddress)\n        .storeCoins(opts.tonAmount)\n        .storeRef(opts.master_msg)\n        .endCell(),\n    });\n  }\n\n  async getJettonData(provider: ContractProvider): Promise<[bigint, boolean, Address, Cell, Cell]> {\n    const {stack} = await provider.get('get_jetton_data', []);\n    return [\n      stack.readBigNumber(),\n      stack.readBoolean(),\n      stack.readAddress(),\n      stack.readCell(),\n      stack.readCell(),\n    ];\n  }\n\n  async getWalletAddress(provider: ContractProvider, owner: Address): Promise<Address> {\n    const tb = new TupleBuilder();\n    tb.writeAddress(owner);\n    const {stack} = await provider.get('get_wallet_address', tb.build());\n    return stack.readAddress();\n  }\n\n  async getBalance(provider: ContractProvider): Promise<bigint> {\n    const state = await provider.getState();\n    return state.balance;\n  }\n\n  async getNextAdminAddress(provider: ContractProvider): Promise<Address> {\n    const result = await provider.get('get_next_admin_address', []);\n    return result.stack.readAddress();\n  }\n}\n","import {\n  Address,\n  Cell,\n  Contract,\n  ContractProvider,\n  SendMode,\n  Sender,\n  Slice,\n  beginCell,\n  contractAddress,\n} from '@ton/core';\n\nexport interface walletConfig {\n  owner_address: Address;\n  jetton_master_address: Address;\n}\n\nexport function walletConfigToCell(config: walletConfig): Cell {\n  return beginCell()\n    .storeUint(0, 4)\n    .storeCoins(0)\n    .storeAddress(config.owner_address)\n    .storeAddress(config.jetton_master_address)\n    .endCell();\n}\n\nexport class UsdtWallet implements Contract {\n  static readonly OPCODES = {\n    TRANSFER: 0xf8a7ea5,\n  };\n\n  constructor(\n    readonly address: Address,\n    readonly init?: {code: Cell; data: Cell},\n  ) {}\n\n  static createFromAddress(address: Address): UsdtWallet {\n    return new UsdtWallet(address);\n  }\n\n  static createFromConfig(config: walletConfig, code: Cell, workchain = 0): UsdtWallet {\n    const data = walletConfigToCell(config);\n    const init = {code, data};\n    return new UsdtWallet(contractAddress(workchain, init), init);\n  }\n\n  async sendDeploy(provider: ContractProvider, via: Sender, value: bigint): Promise<void> {\n    await provider.internal(via, {\n      value,\n      sendMode: SendMode.PAY_GAS_SEPARATELY,\n      body: beginCell().endCell(),\n    });\n  }\n\n  async buildTransfer(\n    provider: ContractProvider,\n    opts: {\n      value: bigint;\n      fromAddress?: Address;\n      toAddress: Address;\n      queryId?: number;\n      fwdAmount: bigint;\n      jettonAmount: bigint;\n    } & (\n      | {\n          forwardPayload?: Cell | Slice | null;\n        }\n      | {\n          comment: string;\n        }\n    ),\n  ) {\n    const builder = beginCell()\n      .storeUint(UsdtWallet.OPCODES.TRANSFER, 32)\n      .storeUint(opts.queryId ?? 69, 64)\n      .storeCoins(opts.jettonAmount)\n      .storeAddress(opts.toAddress)\n      .storeAddress(opts.fromAddress)\n      .storeUint(0, 1)\n      .storeCoins(opts.fwdAmount);\n\n    if ('comment' in opts) {\n      const commentPayload = beginCell().storeUint(0, 32).storeStringTail(opts.comment).endCell();\n\n      builder.storeBit(1);\n      builder.storeRef(commentPayload);\n    } else {\n      if (opts.forwardPayload instanceof Slice) {\n        builder.storeBit(0);\n        builder.storeSlice(opts.forwardPayload);\n      } else if (opts.forwardPayload instanceof Cell) {\n        builder.storeBit(1);\n        builder.storeRef(opts.forwardPayload);\n      } else {\n        builder.storeBit(0);\n      }\n    }\n    return builder.endCell();\n  }\n\n  async sendTransfer(\n    provider: ContractProvider,\n    via: Sender,\n    opts: {\n      value: bigint;\n      toAddress: Address;\n      queryId?: number;\n      fwdAmount: bigint;\n      jettonAmount: bigint;\n    } & (\n      | {\n          forwardPayload?: Cell | Slice | null;\n        }\n      | {\n          comment: string;\n        }\n    ),\n  ): Promise<void> {\n    const body = await this.buildTransfer(provider, {\n      ...opts,\n      fromAddress: via.address,\n    });\n\n    await provider.internal(via, {\n      value: opts.value,\n      sendMode: SendMode.PAY_GAS_SEPARATELY,\n      body: body,\n    });\n  }\n\n  async getData(provider: ContractProvider): Promise<{\n    balance: bigint;\n    owner_address: Address;\n    jetton_master_address: Address;\n    wallet_code: Cell;\n  }> {\n    const {stack} = await provider.get('get_wallet_data', []);\n    return {\n      balance: stack.readBigNumber(),\n      owner_address: stack.readAddress(),\n      jetton_master_address: stack.readAddress(),\n      wallet_code: stack.readCell(),\n    };\n  }\n\n  async getStatus(provider: ContractProvider): Promise<number> {\n    const result = await provider.get('get_status', []);\n    return result.stack.readNumber();\n  }\n\n  async getBalance(provider: ContractProvider): Promise<bigint> {\n    const state = await provider.getState();\n    return state.balance;\n  }\n\n  async getUsdtBalance(provider: ContractProvider): Promise<bigint> {\n    try {\n      const res = await this.getData(provider);\n      return res.balance;\n    } catch (e) {\n      // If non-active we assume it's uninitialized and the balance == 0.\n      // Doesn't work if the contract state gets frozen and compressed\n      if ((e as Error).message === 'Trying to run get method on non-active contract') {\n        return 0n;\n      } else {\n        throw e;\n      }\n    }\n  }\n}\n","import {Address, Contract, ContractProvider} from '@ton/core';\n\nexport abstract class TonBaseMinter implements Contract {\n  constructor(readonly address: Address) {}\n\n  abstract getWalletAddress(provider: ContractProvider, owner: Address): Promise<Address>;\n}\n","import {Address, OpenedContract} from '@ton/ton';\nimport {TonBaseMinter} from './wrappers/TonBaseMinter';\n\nexport const getJettonAddressFromWallet = (\n  contract: OpenedContract<TonBaseMinter>,\n  walletAddress: Address,\n) => {\n  return contract.getWalletAddress(walletAddress).then((jettonWalletAddress) => {\n    return jettonWalletAddress;\n  });\n};\n","import {Transaction, TransactionResult} from '@layerzerolabs/ui-core';\nimport {TonSigner, TonTransaction} from './TonSigner';\nimport {Address, storeMessage, TonClient} from '@ton/ton';\nimport {beginCell, Cell, Transaction as TonClientTransaction} from '@ton/core';\nimport {bigintToAsciiString, clGetUint} from '@layerzerolabs/lz-ton-sdk-v2';\n\ntype CreateTransactionOptions = {\n  client: TonClient;\n};\n\ninterface WaitForTransactionProps {\n  refetchInterval?: number;\n  refetchLimit?: number;\n  address: Address;\n}\n\nconst waitForTransaction = async (\n  options: WaitForTransactionProps,\n  client: TonClient,\n  checkEqual: (a: TonClientTransaction) => boolean,\n): Promise<TonClientTransaction | null> => {\n  const {refetchInterval = 3000, refetchLimit, address} = options;\n\n  return new Promise((resolve) => {\n    let refetches = 0;\n    const walletAddress = address;\n    const interval = setInterval(async () => {\n      refetches += 1;\n\n      const state = await client.getContractState(walletAddress);\n      if (!state || !state.lastTransaction) {\n        clearInterval(interval);\n        resolve(null);\n        return;\n      }\n\n      const {lt: lastLt, hash: lastHash} = state.lastTransaction;\n      const lastTx = await client.getTransaction(walletAddress, lastLt, lastHash);\n\n      if (lastTx && lastTx.inMessage) {\n        if (checkEqual(lastTx)) {\n          clearInterval(interval);\n          resolve(lastTx);\n        }\n      }\n\n      if (refetchLimit && refetches >= refetchLimit) {\n        clearInterval(interval);\n        resolve(null);\n      }\n    }, refetchInterval);\n  });\n};\n\nexport function createTransaction(\n  populatedTransaction: TonTransaction,\n  options: CreateTransactionOptions,\n): Transaction<TonSigner> {\n  const {client} = options;\n  async function unwrap() {\n    return populatedTransaction;\n  }\n\n  async function signAndSubmitTransaction(signer: TonSigner): Promise<TransactionResult> {\n    const responseBoc = await signer.sendTransaction(populatedTransaction);\n\n    const hash = Cell.fromBase64(responseBoc).hash().toString('hex');\n\n    const transaction = await waitForTransaction(\n      {\n        address: signer.getAddress(),\n      },\n      client,\n      (lastTx) => {\n        if (lastTx.inMessage) {\n          const msgCell = beginCell().store(storeMessage(lastTx.inMessage)).endCell();\n          const inMsgHash = msgCell.hash().toString('hex');\n          return inMsgHash === hash;\n        }\n        return false;\n      },\n    );\n    if (!transaction) {\n      throw new Error('Unable to confirm transaction is on chain');\n    }\n\n    return {\n      txHash: '0x' + transaction.hash().toString('hex'),\n      async wait() {\n        await waitForTransaction(\n          {\n            address: signer.getAddress(),\n          },\n          client,\n          (lastTx) => {\n            if (lastTx.inMessage) {\n              const msgCell = beginCell().store(storeMessage(lastTx.inMessage)).endCell();\n              try {\n                const subtopic = bigintToAsciiString(clGetUint(msgCell.refs[0]!, 0, 256));\n                return subtopic === 'Channel::event::PACKET_SENT';\n              } catch (error) {\n                return false;\n              }\n            }\n            return false;\n          },\n        );\n        return {\n          txHash: '0x' + transaction.hash().toString('hex'),\n        };\n      },\n    };\n  }\n\n  const tx: Transaction<TonSigner, TonTransaction> = {\n    signAndSubmitTransaction,\n    estimateGas() {\n      throw new Error('Not implemented');\n    },\n    estimateNative() {\n      throw new Error('Not implemented');\n    },\n    unwrap,\n  };\n  return tx;\n}\n","import {toBigIntBE} from 'bigint-buffer';\nimport {beginCell, Cell} from '@ton/core';\nimport {\n  AddressTypeLike,\n  baseBuildClass,\n  buildClass,\n  emptyCell,\n  emptyMap,\n  emptyPOOO,\n  nullObject,\n} from '@layerzerolabs/lz-ton-sdk-v2';\nimport UlnArtifact from '@layerzerolabs/lz-ton-sdk-v2/artifacts/Uln.compiled.json';\nimport EndpointArtifact from '@layerzerolabs/lz-ton-sdk-v2/artifacts/Endpoint.compiled.json';\nimport UlnConnectionArtifact from '@layerzerolabs/lz-ton-sdk-v2/artifacts/UlnConnection.compiled.json';\nimport ChannelArtifact from '@layerzerolabs/lz-ton-sdk-v2/artifacts/Channel.compiled.json';\n\nconst TON_EID = 30343;\nconst ulnCode = Cell.fromHex(UlnArtifact.hex);\nconst endpointCode = Cell.fromHex(EndpointArtifact.hex);\nconst ulnConnectionCode = Cell.fromHex(UlnConnectionArtifact.hex);\nconst channelCode = Cell.fromHex(ChannelArtifact.hex);\n\nexport function computeContractAddress(code: Cell, storage: Cell): bigint {\n  return toBigIntBE(beginCell().storeUint(6, 5).storeRef(code).storeRef(storage).endCell().hash());\n}\n\nexport const initBaseStorage = (owner: AddressTypeLike) => {\n  return baseBuildClass('BaseStorage', {\n    owner,\n    authenticated: false,\n    initialized: false,\n    initialStorage: emptyCell(),\n  });\n};\n\nexport const getUlnReceiveConfigDefault = () => {\n  return buildClass('UlnReceiveConfig', {\n    minCommitPacketGasNull: true,\n    minCommitPacketGas: 0,\n    confirmationsNull: true,\n    confirmations: 0,\n    requiredDVNsNull: true,\n    requiredDVNs: emptyCell(),\n    optionalDVNsNull: true,\n    optionalDVNs: emptyCell(),\n    optionalDVNThreshold: 0,\n  });\n};\n\nexport const getUlnSendConfigDefault = () => {\n  return buildClass('UlnSendConfig', {\n    workerQuoteGasLimit: 0,\n    maxMessageBytes: 0,\n    executorNull: true,\n    executor: 0n,\n    requiredDVNsNull: true,\n    requiredDVNs: emptyCell(),\n    optionalDVNsNull: true,\n    optionalDVNs: emptyCell(),\n    confirmationsNull: true,\n    confirmations: 0,\n  });\n};\n\n/**\n * Gets the UlnAddress from the UlnManager address\n * @param owner UlnManager address\n * @param dstEid\n */\nexport function computeTonUlnAddress(owner: bigint, dstEid: bigint): bigint {\n  return computeContractAddress(\n    ulnCode,\n    buildClass('Uln', {\n      baseStorage: initBaseStorage(owner),\n      eid: TON_EID,\n      dstEid: dstEid,\n      defaultUlnReceiveConfig: getUlnReceiveConfigDefault(),\n      defaultUlnSendConfig: getUlnSendConfigDefault(),\n      connectionCode: emptyCell(),\n      workerFeelibInfos: emptyMap(),\n      treasuryFeeBps: 0,\n      remainingWorkerSlots: 0,\n      remainingAdminWorkerSlots: 0,\n    }),\n  );\n}\n\nexport function computeTonEndpointAddress(owner: bigint, dstEid: bigint): bigint {\n  return computeContractAddress(\n    endpointCode,\n    buildClass('Endpoint', {\n      baseStorage: initBaseStorage(owner),\n      eid: TON_EID,\n      dstEid,\n      msglibs: emptyMap(),\n      numMsglibs: 0,\n      channelCode: emptyCell(),\n      channelStorageInit: nullObject(),\n      defaultSendLibInfo: nullObject(),\n      defaultReceiveLibInfo: nullObject(),\n      defaultTimeoutReceiveLibInfo: nullObject(),\n      defaultSendMsglibManager: 0n,\n      defaultExpiry: 0,\n    }),\n  );\n}\n\n/**\n *\n * @param owner src OApp address\n * @param dstEid\n * @param dstOApp\n * @param ulnManagerAddress\n * @param ulnAddress Can be derived via computeTonUlnAddress\n */\nexport function computeTonUlnConnectionAddress(\n  owner: bigint,\n  dstEid: bigint,\n  dstOApp: bigint,\n  ulnManagerAddress: bigint,\n  ulnAddress: bigint,\n): bigint {\n  return computeContractAddress(\n    ulnConnectionCode,\n    buildClass('UlnConnection', {\n      baseStorage: initBaseStorage(ulnManagerAddress),\n      path: {\n        srcEid: TON_EID,\n        dstEid,\n        srcOApp: owner,\n        dstOApp,\n      },\n      endpointAddress: 0n,\n      channelAddress: 0n,\n      ulnAddress: ulnAddress,\n      UlnSendConfigOApp: getUlnSendConfigDefault(),\n      UlnReceiveConfigOApp: getUlnReceiveConfigDefault(),\n      hashLookups: emptyMap(),\n      firstUnexecutedNonce: 1,\n      commitPOOO: emptyCell(),\n    }),\n  );\n}\n\n/**\n *\n * @param owner The source OApp address\n * @param dstEid\n * @param dstOApp\n * @param controllerAddress\n * @param endpointAddress endpoint address. Can be derived via computeTonEndpointAddress\n */\nexport function computeTonChannelAddress(\n  owner: bigint,\n  dstEid: bigint,\n  dstOApp: bigint,\n  controllerAddress: bigint,\n  endpointAddress: bigint,\n): bigint {\n  return computeContractAddress(\n    channelCode,\n    buildClass('Channel', {\n      baseStorage: initBaseStorage(controllerAddress),\n      path: {\n        srcEid: TON_EID,\n        dstEid,\n        srcOApp: owner,\n        dstOApp,\n      },\n      endpointAddress: endpointAddress,\n      epConfigOApp: {\n        isNull: true,\n        sendMsglib: 0n,\n        sendMsglibConnection: 0n,\n        sendMsglibManager: 0n,\n        receiveMsglib: 0n,\n        receiveMsglibConnection: 0n,\n        timeoutReceiveMsglib: 0n,\n        timeoutReceiveMsglibConnection: 0n,\n        timeoutReceiveMsglibExpiry: 0,\n      },\n      outboundNonce: 0,\n      sendRequestQueue: emptyCell(),\n      lastSendRequestId: 0,\n      commitPOOO: emptyPOOO(),\n      executePOOO: emptyPOOO(),\n      executionQueue: emptyCell(),\n      zroBalance: 0,\n    }),\n  );\n}\n","'use server';\nimport {Stage} from '@layerzerolabs/ui-core';\nimport {Cell} from '@ton/core';\nimport {bigintToAsciiString, clGetUint} from '@layerzerolabs/lz-ton-sdk-v2';\nimport {parseTonAddress} from './utils';\nimport {trimStart} from 'lodash';\n\nconst STAGE_URLS: Record<Stage, string> = {\n  [Stage.SANDBOX]: 'https://testnet.toncenter.com/api/v3',\n  [Stage.TESTNET]: 'https://testnet.toncenter.com/api/v3',\n  [Stage.MAINNET]:\n    'https://ton-mainnet.core.chainstack.com/8d84e91390521b3e86defd93cb74f934/api/v3',\n};\n\ninterface TraceItem {\n  tx_hash: string;\n  in_msg_hash: string;\n  children: TraceItem[];\n}\n\ninterface MessageItem {\n  hash: string;\n  source: string; // Address in the form of 0:<hash>\n  destination: string;\n  message_content: {\n    hash: string;\n    body: string;\n  };\n}\n\ninterface TransactionItem {\n  hash: string;\n  in_msg: MessageItem;\n  out_msgs: MessageItem[];\n  description: {\n    compute_ph: {\n      skipped: boolean;\n      reason?: string;\n    };\n  };\n}\n\ninterface TraceResponse {\n  trace_id: string;\n  trace: TraceItem;\n  is_incomplete: boolean;\n  trace_info: {\n    trace_state: string;\n    messages: number;\n    transactions: number;\n    pending_messages: number;\n    classification_state: string;\n  };\n  transactions_order: string[];\n  transactions: Record<string, TransactionItem>; // Key is b64 hash\n}\n\ninterface TracesResponse {\n  traces: TraceResponse[];\n}\n\ninterface TraceNode {\n  tx_hash: string;\n  children: TraceNode[];\n}\n\ninterface TraceItem {\n  trace: TraceItem;\n  transactions: Record<string, any>;\n}\n\nconst transformToTransactionTrace = (\n  traceItem: TraceItem,\n  node: TraceNode = traceItem.trace,\n): any => {\n  return {\n    transaction: traceItem.transactions[node.tx_hash],\n    children: node.children.map((child) => transformToTransactionTrace(traceItem, child)),\n  };\n};\n\nexport class TransactionTrace {\n  loading = false;\n  data?: TraceResponse;\n  error?: Error;\n\n  constructor(\n    public readonly txHash: string,\n    protected readonly apiKey: string,\n    public readonly stage: Stage,\n  ) {}\n\n  async waitForComplete(timeoutInMs: number): Promise<void> {\n    while (!this.isCompleted) {\n      await this.update();\n    }\n  }\n\n  async update() {\n    if (this.isCompleted) {\n      return;\n    }\n\n    this.loading = true;\n\n    const tonAddress = parseTonAddress(this.txHash);\n\n    return fetch(\n      `${STAGE_URLS[this.stage]}/events?tx_hash=${trimStart(tonAddress.toRawString(), '0:')}`,\n    )\n      .then(async (res) => {\n        if (res.ok) {\n          const data = await res.json();\n          this.data = data.events[0];\n        }\n      })\n      .catch((error) => {\n        console.log({error});\n      })\n      .finally(() => (this.loading = false));\n  }\n\n  get isCompleted() {\n    return !!this.error || this.data?.trace_info.trace_state === 'complete';\n  }\n\n  get successful() {\n    let foundEmitEvent = false;\n    Object.values(this.data?.transactions ?? {}).forEach((transaction) => {\n      // If it's skipped and no gas, it's possible that this is an event emitted.\n      if (\n        transaction.description.compute_ph.skipped &&\n        transaction.description.compute_ph.reason === 'no_gas'\n      ) {\n        const cell = Cell.fromBase64(transaction.in_msg.message_content.body);\n        const subtopic = bigintToAsciiString(clGetUint(cell.refs[0]!, 0, 256));\n        if (subtopic === 'Channel::event::PACKET_SENT') {\n          foundEmitEvent = true;\n        }\n      }\n    });\n\n    return foundEmitEvent;\n  }\n}\n"]}